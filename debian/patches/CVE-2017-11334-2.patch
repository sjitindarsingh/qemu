Backport of:

From f5aa69bdc3418773f26747ca282c291519626ece Mon Sep 17 00:00:00 2001
From: Anthony PERARD <anthony.perard@citrix.com>
Date: Wed, 26 Jul 2017 17:53:26 +0100
Subject: [PATCH] exec: Add lock parameter to qemu_ram_ptr_length

Commit 04bf2526ce87f21b32c9acba1c5518708c243ad0 (exec: use
qemu_ram_ptr_length to access guest ram) start using qemu_ram_ptr_length
instead of qemu_map_ram_ptr, but when used with Xen, the behavior of
both function is different. They both call xen_map_cache, but one with
"lock", meaning the mapping of guest memory is never released
implicitly, and the second one without, which means, mapping can be
release later, when needed.

In the context of address_space_{read,write}_continue, the ptr to those
mapping should not be locked because it is used immediatly and never
used again.

The lock parameter make it explicit in which context qemu_ram_ptr_length
is called.

Signed-off-by: Anthony PERARD <anthony.perard@citrix.com>
Message-Id: <20170726165326.10327-1-anthony.perard@citrix.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 exec.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

Index: qemu-2.5+dfsg/exec.c
===================================================================
--- qemu-2.5+dfsg.orig/exec.c	2018-02-15 07:32:01.819553662 -0500
+++ qemu-2.5+dfsg/exec.c	2018-02-15 07:37:58.747566551 -0500
@@ -1855,14 +1855,14 @@ unlock:
  * pointer, such as a reference to the region that includes the incoming
  * ram_addr_t.
  */
-static void *qemu_ram_ptr_length(ram_addr_t addr, hwaddr *size)
+static void *qemu_ram_ptr_length(ram_addr_t addr, hwaddr *size, bool lock)
 {
     void *ptr;
     if (*size == 0) {
         return NULL;
     }
     if (xen_enabled()) {
-        return xen_map_cache(addr, *size, 1);
+        return xen_map_cache(addr, *size, lock);
     } else {
         RAMBlock *block;
         rcu_read_lock();
@@ -2564,7 +2564,7 @@ MemTxResult address_space_rw(AddressSpac
             } else {
                 addr1 += memory_region_get_ram_addr(mr);
                 /* RAM case */
-                ptr = qemu_ram_ptr_length(addr1, &l);
+                ptr = qemu_ram_ptr_length(addr1, &l, false);
                 memcpy(ptr, buf, l);
                 invalidate_and_set_dirty(mr, addr1, l);
             }
@@ -2603,7 +2603,7 @@ MemTxResult address_space_rw(AddressSpac
                 }
             } else {
                 /* RAM case */
-                ptr = qemu_ram_ptr_length(mr->ram_addr + addr1, &l);
+                ptr = qemu_ram_ptr_length(mr->ram_addr + addr1, &l, false);
                 memcpy(buf, ptr, l);
             }
         }
@@ -2878,7 +2878,7 @@ void *address_space_map(AddressSpace *as
     memory_region_ref(mr);
     rcu_read_unlock();
     *plen = done;
-    return qemu_ram_ptr_length(raddr + base, plen);
+    return qemu_ram_ptr_length(raddr + base, plen, true);
 }
 
 /* Unmaps a memory region previously mapped by address_space_map().
