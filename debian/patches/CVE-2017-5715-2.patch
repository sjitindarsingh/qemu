Backport of:

From a33a2cfe2f771b360b3422f6cdf566a560860bfc Mon Sep 17 00:00:00 2001
From: Paolo Bonzini <pbonzini@redhat.com>
Date: Tue, 9 Jan 2018 13:45:14 -0200
Subject: [PATCH] i386: Add support for SPEC_CTRL MSR

Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
Message-Id: <20180109154519.25634-3-ehabkost@redhat.com>
Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
---
 target/i386/cpu.h     |  3 +++
 target/i386/kvm.c     | 14 ++++++++++++++
 target/i386/machine.c | 20 ++++++++++++++++++++
 3 files changed, 37 insertions(+)

Index: qemu-2.5+dfsg/target-i386/cpu.h
===================================================================
--- qemu-2.5+dfsg.orig/target-i386/cpu.h	2018-01-23 08:13:32.637325154 -0500
+++ qemu-2.5+dfsg/target-i386/cpu.h	2018-01-23 08:13:32.637325154 -0500
@@ -316,6 +316,7 @@
 #define MSR_IA32_APICBASE_BASE          (0xfffffU<<12)
 #define MSR_IA32_FEATURE_CONTROL        0x0000003a
 #define MSR_TSC_ADJUST                  0x0000003b
+#define MSR_IA32_SPEC_CTRL              0x48
 #define MSR_IA32_TSCDEADLINE            0x6e0
 
 #define MSR_P6_PERFCTR0                 0xc1
@@ -905,6 +906,8 @@ typedef struct CPUX86State {
     uint64_t pat;
     uint32_t smbase;
 
+    uint64_t spec_ctrl;
+
     /* End of state preserved by INIT (dummy marker).  */
     struct {} end_init_save;
 
Index: qemu-2.5+dfsg/target-i386/kvm.c
===================================================================
--- qemu-2.5+dfsg.orig/target-i386/kvm.c	2018-01-23 08:13:32.637325154 -0500
+++ qemu-2.5+dfsg/target-i386/kvm.c	2018-01-23 08:13:32.637325154 -0500
@@ -88,6 +88,7 @@ static bool has_msr_hv_vpindex;
 static bool has_msr_hv_runtime;
 static bool has_msr_mtrr;
 static bool has_msr_xss;
+static bool has_msr_spec_ctrl;
 
 static bool has_msr_architectural_pmu;
 static uint32_t num_architectural_pmu_counters;
@@ -920,6 +921,10 @@ static int kvm_get_supported_msrs(KVMSta
                     has_msr_tsc_adjust = true;
                     continue;
                 }
+                if (kvm_msr_list->indices[i] == MSR_IA32_SPEC_CTRL) {
+                    has_msr_spec_ctrl = true;
+                    continue;
+                }
                 if (kvm_msr_list->indices[i] == MSR_IA32_TSCDEADLINE) {
                     has_msr_tsc_deadline = true;
                     continue;
@@ -1433,6 +1438,9 @@ static int kvm_put_msrs(X86CPU *cpu, int
     if (has_msr_xss) {
         kvm_msr_entry_set(&msrs[n++], MSR_IA32_XSS, env->xss);
     }
+    if (has_msr_spec_ctrl) {
+        kvm_msr_entry_set(&msrs[n++], MSR_IA32_SPEC_CTRL, env->spec_ctrl);
+    }
 #ifdef TARGET_X86_64
     if (lm_capable_kernel) {
         kvm_msr_entry_set(&msrs[n++], MSR_CSTAR, env->cstar);
@@ -1441,6 +1448,7 @@ static int kvm_put_msrs(X86CPU *cpu, int
         kvm_msr_entry_set(&msrs[n++], MSR_LSTAR, env->lstar);
     }
 #endif
+
     /*
      * The following MSRs have side effects on the guest or are too heavy
      * for normal writeback. Limit them to reset or full state updates.
@@ -1817,6 +1825,9 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (has_msr_xss) {
         msrs[n++].index = MSR_IA32_XSS;
     }
+    if (has_msr_spec_ctrl) {
+        msrs[n++].index = MSR_IA32_SPEC_CTRL;
+    }
 
 
     if (!env->tsc_valid) {
@@ -2084,6 +2095,9 @@ static int kvm_get_msrs(X86CPU *cpu)
                 env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;
             }
             break;
+        case MSR_IA32_SPEC_CTRL:
+            env->spec_ctrl = msrs[i].data;
+            break;
         }
     }
 
Index: qemu-2.5+dfsg/target-i386/machine.c
===================================================================
--- qemu-2.5+dfsg.orig/target-i386/machine.c	2018-01-23 08:13:32.637325154 -0500
+++ qemu-2.5+dfsg/target-i386/machine.c	2018-01-23 08:14:00.865343019 -0500
@@ -775,6 +775,25 @@ static const VMStateDescription vmstate_
     }
 };
 
+static bool spec_ctrl_needed(void *opaque)
+{
+    X86CPU *cpu = opaque;
+    CPUX86State *env = &cpu->env;
+
+    return env->spec_ctrl != 0;
+}
+
+static const VMStateDescription vmstate_spec_ctrl = {
+    .name = "cpu/spec_ctrl",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .needed = spec_ctrl_needed,
+    .fields = (VMStateField[]){
+        VMSTATE_UINT64(env.spec_ctrl, X86CPU),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
 VMStateDescription vmstate_x86_cpu = {
     .name = "cpu",
     .version_id = 12,
@@ -895,6 +914,7 @@ VMStateDescription vmstate_x86_cpu = {
         &vmstate_msr_hyperv_runtime,
         &vmstate_avx512,
         &vmstate_xss,
+        &vmstate_spec_ctrl,
         NULL
     }
 };
