Workaround for a historic VMX bug in the kvm kernel module.

This bug was introduced in Linux 2.6.38 and fixed in Linux 3.0 (kernel git
commit 5233dd51ece1615d54ab96c4cbe9ac3cc595e955). 

If QEMU calls KVM_SET_REGS on a vcpu with paging enabled (cr0.PG=1) prior to the
KVM_SET_REGS call, then kvm will ignore sregs.cr3 and overwrite the guest's CR3
with with whatever was in the GUEST_CR3 field of the VCPU's VMCS (i.e., some
stale value of CR3). This stale value only seems to matter in the following
situation:

   1. Create VM with incoming migration and -S (i.e., start in a paused
      state).
   2. Issue any monitor command that calls kvm_arch_get_registers (e.g.,
      info cpus, info tlb, etc.)
   3. Continue the VM.
   4. qemu calls KVM_SET_REGS b/c it might have dirty registers in user memory.
   5. KVM bug sets CR3 to stale value.
   6. The VM triple faults because of a bad cr3.

Unfortunately, we come across this situation with libvirt on every clone launch
(i.e., we use qemu's migration code, libvirt stats VMs paused & does an "info
cpus" before continuing them).

This hack suppresses KVM_SET_REGS in step 4. This isn't a problem because the
registers in user memory aren't actually dirty as a result of "info cpus". If
the registers were dirty, then we'd have another bug ...

Signed-off-by: Peter Feiner <peter@gridcentric.com>

Index: qemu/target-i386/cpu.h
===================================================================
--- qemu.orig/target-i386/cpu.h	2013-01-17 10:57:00.128404663 -0600
+++ qemu/target-i386/cpu.h	2013-01-17 10:57:00.120404663 -0600
@@ -833,6 +833,7 @@
     uint32_t cpuid_svm_features;
     bool tsc_valid;
     int tsc_khz;
+    int kvm_has_run;
     void *kvm_xsave_buf;
 
     /* in order to simplify APIC support, we leave this pointer to the
Index: qemu/target-i386/kvm.c
===================================================================
--- qemu.orig/target-i386/kvm.c	2013-01-17 10:57:00.128404663 -0600
+++ qemu/target-i386/kvm.c	2013-01-17 10:57:00.120404663 -0600
@@ -1589,6 +1589,10 @@
 
     assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
 
+    if (!env->kvm_has_run && level == KVM_PUT_RUNTIME_STATE) {
+        return 0;
+    }
+
     ret = kvm_getput_regs(env, 1);
     if (ret < 0) {
         return ret;
@@ -1755,6 +1759,7 @@
     }
     cpu_set_apic_tpr(env->apic_state, run->cr8);
     cpu_set_apic_base(env->apic_state, run->apic_base);
+    env->kvm_has_run = 1;
 }
 
 int kvm_arch_process_async_events(CPUX86State *env)
