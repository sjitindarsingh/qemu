From 3550a9043d1fd6660418360c19d9e899278a7496 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Juha=20Riihim=C3=A4ki?= <juha.riihimaki@nokia.com>
Date: Wed, 4 Jul 2012 11:18:33 +0000
Subject: [PATCH 03/77] sd: Allow sd_init callers to specify whether card is
 MMC or SD

Add a parameter to sd_init() which allows the caller to specify
whether the card is MMC or SD.

TODO: maybe we should have an sd_init() and an mmc_init()
instead?

TODO: these mmc patches need to be integrated with the ones
Vincent Palatin proposed.
---
 hw/milkymist-memcard.c |    2 +-
 hw/omap_mmc.c          |    4 ++--
 hw/pl181.c             |    2 +-
 hw/pxa2xx_mmci.c       |    2 +-
 hw/sd.c                |    2 +-
 hw/sd.h                |    2 +-
 hw/ssi-sd.c            |    2 +-
 7 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/hw/milkymist-memcard.c b/hw/milkymist-memcard.c
index 3515c3c..a08b2f0 100644
--- a/hw/milkymist-memcard.c
+++ b/hw/milkymist-memcard.c
@@ -250,7 +250,7 @@ static int milkymist_memcard_init(SysBusDevice *dev)
     DriveInfo *dinfo;
 
     dinfo = drive_get_next(IF_SD);
-    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0);
+    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0, 0);
     s->enabled = dinfo ? bdrv_is_inserted(dinfo->bdrv) : 0;
 
     memory_region_init_io(&s->regs_region, &memcard_mmio_ops, s,
diff --git a/hw/omap_mmc.c b/hw/omap_mmc.c
index aec0285..2e80e9a 100644
--- a/hw/omap_mmc.c
+++ b/hw/omap_mmc.c
@@ -592,7 +592,7 @@ struct omap_mmc_s *omap_mmc_init(target_phys_addr_t base,
     memory_region_add_subregion(sysmem, base, &s->iomem);
 
     /* Instantiate the storage */
-    s->card = sd_init(bd, 0);
+    s->card = sd_init(bd, 0, 0);
 
     return s;
 }
@@ -617,7 +617,7 @@ struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
     omap_l4_attach(ta, 0, &s->iomem);
 
     /* Instantiate the storage */
-    s->card = sd_init(bd, 0);
+    s->card = sd_init(bd, 0, 0);
 
     s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
     sd_set_cb(s->card, NULL, s->cdet);
diff --git a/hw/pl181.c b/hw/pl181.c
index 7d91fbb..cf14f3e 100644
--- a/hw/pl181.c
+++ b/hw/pl181.c
@@ -483,7 +483,7 @@ static int pl181_init(SysBusDevice *dev)
     sysbus_init_irq(dev, &s->irq[1]);
     qdev_init_gpio_out(&s->busdev.qdev, s->cardstatus, 2);
     dinfo = drive_get_next(IF_SD);
-    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0);
+    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0, 0);
     return 0;
 }
 
diff --git a/hw/pxa2xx_mmci.c b/hw/pxa2xx_mmci.c
index b505a4c..7c53b82 100644
--- a/hw/pxa2xx_mmci.c
+++ b/hw/pxa2xx_mmci.c
@@ -538,7 +538,7 @@ PXA2xxMMCIState *pxa2xx_mmci_init(MemoryRegion *sysmem,
     memory_region_add_subregion(sysmem, base, &s->iomem);
 
     /* Instantiate the actual storage */
-    s->card = sd_init(bd, 0);
+    s->card = sd_init(bd, 0, 0);
 
     register_savevm(NULL, "pxa2xx_mmci", 0, 0,
                     pxa2xx_mmci_save, pxa2xx_mmci_load, s);
diff --git a/hw/sd.c b/hw/sd.c
index f2fb1c3..78999ae 100644
--- a/hw/sd.c
+++ b/hw/sd.c
@@ -448,7 +448,7 @@ static const BlockDevOps sd_block_ops = {
    whether card should be in SSI or MMC/SD mode.  It is also up to the
    board to ensure that ssi transfers only occur when the chip select
    is asserted.  */
-SDState *sd_init(BlockDriverState *bs, bool is_spi)
+SDState *sd_init(BlockDriverState *bs, bool is_spi, bool is_mmc)
 {
     SDState *sd;
 
diff --git a/hw/sd.h b/hw/sd.h
index e1eebd1..cff7011 100644
--- a/hw/sd.h
+++ b/hw/sd.h
@@ -67,7 +67,7 @@ typedef struct {
 
 typedef struct SDState SDState;
 
-SDState *sd_init(BlockDriverState *bs, bool is_spi);
+SDState *sd_init(BlockDriverState *bs, bool is_spi, bool is_mmc);
 void sd_reset(SDState *sd);
 int sd_do_command(SDState *sd, SDRequest *req,
                   uint8_t *response);
diff --git a/hw/ssi-sd.c b/hw/ssi-sd.c
index b519bdb..8f41f5e 100644
--- a/hw/ssi-sd.c
+++ b/hw/ssi-sd.c
@@ -239,7 +239,7 @@ static int ssi_sd_init(SSISlave *dev)
 
     s->mode = SSI_SD_CMD;
     dinfo = drive_get_next(IF_SD);
-    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, 1);
+    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, 1, 0);
     register_savevm(&dev->qdev, "ssi_sd", -1, 1, ssi_sd_save, ssi_sd_load, s);
     return 0;
 }
-- 
1.7.9.5

