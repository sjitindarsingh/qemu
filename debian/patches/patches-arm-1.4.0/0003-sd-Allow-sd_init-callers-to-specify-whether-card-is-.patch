From b90f374decc9105eb3cff5db721ed4b6a92b00c2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Juha=20Riihim=C3=A4ki?= <juha.riihimaki@nokia.com>
Date: Mon, 18 Feb 2013 16:58:23 +0000
Subject: [PATCH 03/77] sd: Allow sd_init callers to specify whether card is
 MMC or SD

Add a parameter to sd_init() which allows the caller to specify
whether the card is MMC or SD.

TODO: maybe we should have an sd_init() and an mmc_init()
instead?

TODO: these mmc patches need to be integrated with the ones
Vincent Palatin proposed.
---
 hw/milkymist-memcard.c | 2 +-
 hw/omap_mmc.c          | 4 ++--
 hw/pl181.c             | 2 +-
 hw/pxa2xx_mmci.c       | 2 +-
 hw/sd.c                | 2 +-
 hw/sd.h                | 2 +-
 hw/ssi-sd.c            | 2 +-
 7 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/hw/milkymist-memcard.c b/hw/milkymist-memcard.c
index 9d15309..d428b16 100644
--- a/hw/milkymist-memcard.c
+++ b/hw/milkymist-memcard.c
@@ -250,7 +250,7 @@ static int milkymist_memcard_init(SysBusDevice *dev)
     DriveInfo *dinfo;
 
     dinfo = drive_get_next(IF_SD);
-    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0);
+    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0, 0);
     s->enabled = dinfo ? bdrv_is_inserted(dinfo->bdrv) : 0;
 
     memory_region_init_io(&s->regs_region, &memcard_mmio_ops, s,
diff --git a/hw/omap_mmc.c b/hw/omap_mmc.c
index 7ecd9bd..8908d35 100644
--- a/hw/omap_mmc.c
+++ b/hw/omap_mmc.c
@@ -592,7 +592,7 @@ struct omap_mmc_s *omap_mmc_init(hwaddr base,
     memory_region_add_subregion(sysmem, base, &s->iomem);
 
     /* Instantiate the storage */
-    s->card = sd_init(bd, 0);
+    s->card = sd_init(bd, 0, 0);
 
     return s;
 }
@@ -617,7 +617,7 @@ struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
     omap_l4_attach(ta, 0, &s->iomem);
 
     /* Instantiate the storage */
-    s->card = sd_init(bd, 0);
+    s->card = sd_init(bd, 0, 0);
 
     s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
     sd_set_cb(s->card, NULL, s->cdet);
diff --git a/hw/pl181.c b/hw/pl181.c
index 98529f7..4996cba 100644
--- a/hw/pl181.c
+++ b/hw/pl181.c
@@ -485,7 +485,7 @@ static int pl181_init(SysBusDevice *dev)
     sysbus_init_irq(dev, &s->irq[1]);
     qdev_init_gpio_out(&s->busdev.qdev, s->cardstatus, 2);
     dinfo = drive_get_next(IF_SD);
-    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0);
+    s->card = sd_init(dinfo ? dinfo->bdrv : NULL, 0, 0);
     return 0;
 }
 
diff --git a/hw/pxa2xx_mmci.c b/hw/pxa2xx_mmci.c
index 3589968..270dcfb 100644
--- a/hw/pxa2xx_mmci.c
+++ b/hw/pxa2xx_mmci.c
@@ -538,7 +538,7 @@ PXA2xxMMCIState *pxa2xx_mmci_init(MemoryRegion *sysmem,
     memory_region_add_subregion(sysmem, base, &s->iomem);
 
     /* Instantiate the actual storage */
-    s->card = sd_init(bd, 0);
+    s->card = sd_init(bd, 0, 0);
 
     register_savevm(NULL, "pxa2xx_mmci", 0, 0,
                     pxa2xx_mmci_save, pxa2xx_mmci_load, s);
diff --git a/hw/sd.c b/hw/sd.c
index ed73285..c53815b 100644
--- a/hw/sd.c
+++ b/hw/sd.c
@@ -486,7 +486,7 @@ static const VMStateDescription sd_vmstate = {
    whether card should be in SSI or MMC/SD mode.  It is also up to the
    board to ensure that ssi transfers only occur when the chip select
    is asserted.  */
-SDState *sd_init(BlockDriverState *bs, bool is_spi)
+SDState *sd_init(BlockDriverState *bs, bool is_spi, bool is_mmc)
 {
     SDState *sd;
 
diff --git a/hw/sd.h b/hw/sd.h
index 4ef822f..562eaa2 100644
--- a/hw/sd.h
+++ b/hw/sd.h
@@ -68,7 +68,7 @@ typedef struct {
 
 typedef struct SDState SDState;
 
-SDState *sd_init(BlockDriverState *bs, bool is_spi);
+SDState *sd_init(BlockDriverState *bs, bool is_spi, bool is_mmc);
 void sd_reset(SDState *sd);
 int sd_do_command(SDState *sd, SDRequest *req,
                   uint8_t *response);
diff --git a/hw/ssi-sd.c b/hw/ssi-sd.c
index dca8906..271e82d 100644
--- a/hw/ssi-sd.c
+++ b/hw/ssi-sd.c
@@ -245,7 +245,7 @@ static int ssi_sd_init(SSISlave *dev)
 
     s->mode = SSI_SD_CMD;
     dinfo = drive_get_next(IF_SD);
-    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, 1);
+    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, 1, 0);
     register_savevm(&dev->qdev, "ssi_sd", -1, 1, ssi_sd_save, ssi_sd_load, s);
     return 0;
 }
-- 
1.8.1.2

