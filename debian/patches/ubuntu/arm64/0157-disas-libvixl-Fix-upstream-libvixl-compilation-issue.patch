From 08282e674b308ba3ca12cc39e64fd7d82e2f9872 Mon Sep 17 00:00:00 2001
From: Peter Maydell <peter.maydell@linaro.org>
Date: Wed, 5 Feb 2014 17:27:28 +0000
Subject: [PATCH 157/158] disas/libvixl: Fix upstream libvixl compilation
 issues

Fix various minor issues with upstream libvixl so that it will compile
successfully on the platforms QEMU cares about:
 * remove unused GBytes constant (it clashes with the glib headers)
 * fix suffixes on constants to use 'LL' for 64 bit constants so
   we can compile on 32 bit hosts

Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
Reviewed-by: Richard Henderson <rth@twiddle.net>
---
 disas/libvixl/a64/instructions-a64.h | 30 +++++++++++++++---------------
 disas/libvixl/globals.h              |  1 -
 disas/libvixl/utils.h                |  4 ++--
 3 files changed, 17 insertions(+), 18 deletions(-)

diff --git a/disas/libvixl/a64/instructions-a64.h b/disas/libvixl/a64/instructions-a64.h
index 0f31fcd..ba9068c 100644
--- a/disas/libvixl/a64/instructions-a64.h
+++ b/disas/libvixl/a64/instructions-a64.h
@@ -53,19 +53,19 @@ const unsigned kSRegSizeInBytes = kSRegSize / 8;
 const unsigned kDRegSize = 64;
 const unsigned kDRegSizeLog2 = 6;
 const unsigned kDRegSizeInBytes = kDRegSize / 8;
-const int64_t kWRegMask = 0x00000000ffffffffL;
-const int64_t kXRegMask = 0xffffffffffffffffL;
-const int64_t kSRegMask = 0x00000000ffffffffL;
-const int64_t kDRegMask = 0xffffffffffffffffL;
-const int64_t kXSignMask = 0x1L << 63;
-const int64_t kWSignMask = 0x1L << 31;
+const int64_t kWRegMask = 0x00000000ffffffffLL;
+const int64_t kXRegMask = 0xffffffffffffffffLL;
+const int64_t kSRegMask = 0x00000000ffffffffLL;
+const int64_t kDRegMask = 0xffffffffffffffffLL;
+const int64_t kXSignMask = 0x1LL << 63;
+const int64_t kWSignMask = 0x1LL << 31;
 const int64_t kByteMask = 0xffL;
 const int64_t kHalfWordMask = 0xffffL;
-const int64_t kWordMask = 0xffffffffL;
-const uint64_t kXMaxUInt = 0xffffffffffffffffUL;
-const uint64_t kWMaxUInt = 0xffffffffUL;
-const int64_t kXMaxInt = 0x7fffffffffffffffL;
-const int64_t kXMinInt = 0x8000000000000000L;
+const int64_t kWordMask = 0xffffffffLL;
+const uint64_t kXMaxUInt = 0xffffffffffffffffULL;
+const uint64_t kWMaxUInt = 0xffffffffULL;
+const int64_t kXMaxInt = 0x7fffffffffffffffLL;
+const int64_t kXMinInt = 0x8000000000000000LL;
 const int32_t kWMaxInt = 0x7fffffff;
 const int32_t kWMinInt = 0x80000000;
 const unsigned kLinkRegCode = 30;
@@ -81,16 +81,16 @@ const unsigned kFloatExponentBits = 8;
 
 const float kFP32PositiveInfinity = rawbits_to_float(0x7f800000);
 const float kFP32NegativeInfinity = rawbits_to_float(0xff800000);
-const double kFP64PositiveInfinity = rawbits_to_double(0x7ff0000000000000UL);
-const double kFP64NegativeInfinity = rawbits_to_double(0xfff0000000000000UL);
+const double kFP64PositiveInfinity = rawbits_to_double(0x7ff0000000000000ULL);
+const double kFP64NegativeInfinity = rawbits_to_double(0xfff0000000000000ULL);
 
 // This value is a signalling NaN as both a double and as a float (taking the
 // least-significant word).
-static const double kFP64SignallingNaN = rawbits_to_double(0x7ff000007f800001);
+static const double kFP64SignallingNaN = rawbits_to_double(0x7ff000007f800001ULL);
 static const float kFP32SignallingNaN = rawbits_to_float(0x7f800001);
 
 // A similar value, but as a quiet NaN.
-static const double kFP64QuietNaN = rawbits_to_double(0x7ff800007fc00001);
+static const double kFP64QuietNaN = rawbits_to_double(0x7ff800007fc00001ULL);
 static const float kFP32QuietNaN = rawbits_to_float(0x7fc00001);
 
 enum LSDataSize {
diff --git a/disas/libvixl/globals.h b/disas/libvixl/globals.h
index 859ea69..a6a3fcc 100644
--- a/disas/libvixl/globals.h
+++ b/disas/libvixl/globals.h
@@ -44,7 +44,6 @@ typedef uint8_t byte;
 
 const int KBytes = 1024;
 const int MBytes = 1024 * KBytes;
-const int GBytes = 1024 * MBytes;
 
   #define ABORT() printf("in %s, line %i", __FILE__, __LINE__); abort()
 #ifdef DEBUG
diff --git a/disas/libvixl/utils.h b/disas/libvixl/utils.h
index 4e0b367..029341e 100644
--- a/disas/libvixl/utils.h
+++ b/disas/libvixl/utils.h
@@ -36,7 +36,7 @@ namespace vixl {
 // Check number width.
 inline bool is_intn(unsigned n, int64_t x) {
   ASSERT((0 < n) && (n < 64));
-  int64_t limit = 1L << (n - 1);
+  int64_t limit = 1ULL << (n - 1);
   return (-limit <= x) && (x < limit);
 }
 
@@ -47,7 +47,7 @@ inline bool is_uintn(unsigned n, int64_t x) {
 
 inline unsigned truncate_to_intn(unsigned n, int64_t x) {
   ASSERT((0 < n) && (n < 64));
-  return (x & ((1L << n) - 1));
+  return (x & ((1ULL << n) - 1));
 }
 
 #define INT_1_TO_63_LIST(V)                                                    \
-- 
1.9.rc1

