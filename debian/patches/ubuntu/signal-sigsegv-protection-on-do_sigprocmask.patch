Date: Sat, 20 Oct 2012 16:15:57 +0200
Description: signal: sigsegv protection on do_sigprocmask
 Create a safe wrapper by protecting the signal mask.
 .
 Instead of doing a simple passthrough of the sigprocmask, the wrapper
 manipulates the signal mask in a safe way for the qemu internal. This
 is done by avoiding SIGSEGV bit mask manipulation from the guest.
 .
 We also return the same bit on the SIGSEGV. This is not required for
 most applications, but if the application checks it, then it will see
 that somethings fishy about it (and, in fact, maybe it should). If we
 do not want the guest to be aware of those manipulations, then it should
 be implemented in another way, but this seems quite clean and consistent.
 .
 The wrapper can be improved to add more features for better signal
 managing, but this seems enough for "simple" self-modifying code.
Author: Alex Barcelo <abarcelo@ac.upc.edu>
Origin: https://github.com/susematz/qemu/commit/63eb8d3ea58f58d5857153b0c632def1bbd05781
Last-Update: 2014-02-26

Index: qemu/linux-user/signal.c
===================================================================
--- qemu.orig/linux-user/signal.c	2014-02-27 16:33:43.419646125 -0600
+++ qemu/linux-user/signal.c	2014-02-27 16:37:45.975642018 -0600
@@ -5661,7 +5661,28 @@ long do_rt_sigreturn(CPUArchState *env)
  */
 int do_sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
 {
+#ifdef TARGET_AARCH64
+    int ret;
+    sigset_t val;
+    sigset_t *temp;
+    if (set) {
+        val = *set;
+        temp = &val;
+        sigdelset(temp, SIGSEGV);
+    } else {
+        temp = NULL;
+    }
+    ret = sigprocmask(how, temp, oldset);
+
+    /* Force set state of SIGSEGV, may be best for some apps, maybe not so good
+     * This is not required for qemu to work */
+    if (oldset) {
+        sigaddset(oldset, SIGSEGV);
+    }
+    return ret;
+#else
     return sigprocmask(how, set, oldset);
+#endif
 }
 
 void process_pending_signals(CPUArchState *cpu_env)
